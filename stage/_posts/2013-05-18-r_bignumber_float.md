---
layout: post
title: "R中的大数和小数"
published: false
description: ""
category: R
tags: [R,大数,浮点数]
---
{% include JB/setup %}
今天又在论坛中看到了关于浮点数的问题，稍微了解点计算机知识的人知道，浮点问题就像一个幽灵一直不散，我们要知道一开始的计算机是不支持浮点运算的，毕竟很多数字是无法准确地表示数浮点数。想到以前我也纠结于此（其实，我现在仍然纠结于此），就想对R中的浮点数和大数加深下理解。

# 浮点数的准确性
实数在R中是以双精度数储存的，这就意味这浮点数是用53个bit位表示的。这从下面的示例中可以看出来
{% highlight r linenos%}
1 + 2^-52 == 1 # [1] FALSE
1 + 2^-53 == 1 # [1] TRUE
{% endhighlight %}
数字```1+2^-52```这样一个只有53比特位的尾数的数字是可以被精确描述的，但是对于```1+2…^53```这种具有54比特位尾数的数字就无能为力了，只能当作1来处理。在```[1,2)```间隔中能被描述的的两个数之间的最小间隔大约为**2.220446e-16**(而这个数正好是2^-52次方)。比如下面的例子：
{% highlight r %}
diff(1 + (0:5)*2^-52)
# [1] 2.220446e-16 2.220446e-16 2.220446e-16 2.220446e-16 2.220446e-16
{% endhighlight %}
在那些要求速度的场合下双精度是数值计算的标准。这样做是无法表示无理数以及那些分母不是2的次方数的有理数的。特别地，用于有限位数的十进制数转化为二进制数的时候大可不必有个有限的扩展。这就是下面这个例子的原因：
{% highlight r %}
0.1 + 0.2 - 0.3 # [1] 5.551115e-17
{% endhighlight %}
相同的影响可能表现在使用十进制数的时候。上面的原因也了一用来解释为什么2/3-1/3-1/3为什么不等与0，如果我们把1/3，2/3去近似为有限位十进制数的话，取5位小数，呢么我们就会得到0.66667 - 0.33333 - 0.33333 = 0.00001。
