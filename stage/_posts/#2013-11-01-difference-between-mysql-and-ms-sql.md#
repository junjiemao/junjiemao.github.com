B1;3201;0c---
layout: post
title: "MySQL和MS SQL Server的一些区别"
description: ""
category: 数据库
tags: [MySQL,MS SQL]
---
{% include JB/setup %}
以前也用过MySQL的数据库，但是主要使用的都是查询，几乎没有使用到触发器、存储过程和函数等功能，最近需要从MS SQL Server迁移到MySQL，在使用过程中发现了一些区别，记录下来。关于查询语句的区别就不说了，主要说说触发器和存储过程等等的却别。

# 触发器
在MySQL中触发器的语法和MS SQL有点区别，下面是一个实例：
{% highlight sql linenos %}
DELIMITER $$
CREATE
DEFINER=`root`@`localhost`
TRIGGER `test`.`t_afterinsert_on_tab1`
AFTER INSERT ON `test`.`test`
FOR EACH ROW
BRGIN
sql语句；
END$$
{% endhighlight %}
和MS SQL不同的是MySQL的触发器类型有六种，分别是AFTER/BEFORE和INSERT/UPDATE/DELETE之间的组合。而MS SQL的触发器为INSERT,UPDATE,DELETE以及INSTEAD OF四种，其中前三种是之后触发，最后一种是之前触发。如果使用习惯了MS SQL的话，在写触发器中的SQL语句就会遇到一个小小的坑。比如有一张表格有x和y两列，需要一个触发器判断x大于0就插入x否则插入-x。如果习惯了M$ SQL会这样写：
{% highlight sql linenos %}
DELIMITER $$
CREATE TRIGGER	'test'.'error_trigger'
BEFORE INSTER ON `test`.`test`
FOR EACH　ROW
BEGIN
if new.x<0 then
inster into test values(-new.x,new.y);
else
inster into test values(new.x,new.y);
end if;
END$$
DELIMITER;
{% endhighlight %}
但是这样话的话是无法运行的，因为这样已经相当于循环插入了，正确的做法是
{% highlight sql linenos %}
DELIMITER $$
CREATE TRIGGER	'test'.'error_trigger'
BEFORE INSTER ON `test`.`test`
FOR EACH　ROW
BEGIN
if new.x<0 then
set new.x=-new.x
else
new.x=new.x #也可以不要这句
end if;
END$$
DELIMITER ;
{% endhighlight %}
在写触发器的时候还要注意的就是new和old的使用，new加上点(.)加上列名就可以取出相应的列，old在删除的时候会用得比较多点。而在MS SQL中是需要使用```select```来取出的。


# 存储过程

存储过程没有很大的区别，在MySQL中定义变量是不需要使用```@```符号的。并且其声明参数的格式为```输入（IN）变量还是输出（OUT）变量  变量名 变量类型```，比如 ```IN par_name INT```这种就可以了。

在给变量赋值的时候和MS SQL也是有点区别的，在SQL中可elct  @a=a,@b=b from test 
其中@a @b为声明的变量
而在MySQL中只能
selet a,b into aa,bb  form test  
 其中aa和bb为声明的变量

RRROR 1093错误经常发生在修改A表的时候使用了A表, 比如 A表中x，y列
那么
UPDATE A
set A.x=new.x
where x in select x from A as t_xxxx;
这样是会报错的，解决方案为

UPDATE A
set A.x=new.x
where x in
select x from(select x from A as t_xxxx)
猜想，这可能和SQL语句的内部执行顺序是有关系的，必须在更新之前查找出数据存入临时表中以备用。
